/**
 *
 * @author thermi
 */
package algoprojekt.PrecomputationPhase;

import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.ObjectInputStream;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Hashtable;
import java.util.Random;
import java.security.SecureRandom;

/**
 * This class needs to be instanciated first before it can be used.
 * <P> When it is instantiated, it can be used to generate passwords according to
 * a number of parameters.
 */
public class PrecomputationPhase {

    Random gen = new Random();
    SecureRandom secgen = new SecureRandom();
    int reSeedThreshold;

    /**
     * This constructor sets the rekeythreshold to the given value.
     */
    public PreComputationPhase(int threshold) {
        reSeedThreshold = threshold;
    }
    /**
     * This constructor seeds the PRNG with the given value.
     */
    public PreComputationPhase(long seed) {

    }
    /** This method reseeds the PRNG in the object a value from
     * the RNG.
     */
    public void reSeed()
    {
        gen.setSeed(ByteBuffer.wrap(secgen.generateSeed(8)).getLong());
    }

    /** This method sets the reSeedThreshold to the given value.
     *
     */
    public void setReSeedThreshold(int treshold){
        reSeedThreshold = treshold;
    }

    /**
     * This function generates a valid password with no control characters in
     * it. <P> It is using Java's PRNG class Random with a seed generated by
     * SecureRandom. The characters in the password are ones from this string:
     * "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890!ยง$%&/()=?`'+*#-.:,;"
     *
     */
    public String generatePassword() {
        /* We still need a
         *
         */
        StringBuilder password = new StringBuilder();
        char candidate;
        String legalchars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmno"
                + "pqrstuvwxyz1234567890!ยง$%&/()=?`'+*#-.:,;";
        int i, j, k = 0;
        byte[] buf;
        ByteBuffer bb;
        byte[] r = new byte[1];
        boolean isLegal = false;
        /*
         * We need a somewhat random byte stream, but because we're good guys
         * we don't use secureRandom directly as a RNG to fill the hash table.
         * We instead seed our PRNG with a random value from the RNG,
         * so we don't get the same hash table every time the program is run
         */

        /* Generate a seed */
        buf = secgen.generateSeed(8);

        /* Wrap the seed, so we can get it's long value */
        bb = ByteBuffer.wrap(buf);

        /* Set the seed of the PRNG */
        gen.setSeed(bb.getLong());

        for (i = 0; i <= 6; i++) {

            /* Get the first random byte in a byte array form */
            gen.nextBytes(r);

            /* Wrap the random byte, so we can get its character
             * representation
             */

            bb = ByteBuffer.wrap(r);


            candidate = bb.getChar(0);
            /*
             * We filter the the output of the RNG, so no control characters are
             * in the password. If there were any in the password, it wouldW
             * screw up either System.out.println() or the attached
             * terminal.
             */
            while (!isLegal) {
                /*
                 * We reseed the PRNG every 150 rounds to avoid even short loops.
                 */
                if (k == 150) {
                    /*
                     * This is just a compressed version of what we do at the
                     * beginning of the method.
                     */
                    gen.setSeed(ByteBuffer.wrap(secgen.generateSeed(8)).getLong());
                    k=0;
                }
                /*
                 * We check if the random character is a legal character
                 */

                for (j = 0; j < legalchars.length() && !isLegal; j++) {
                    if (legalchars.charAt(j) == candidate) {
                        isLegal = true;
                    }
                }
                /*
                 * If it isn't a legal character, we get a new one.
                 */
                if (!isLegal) {
                    gen.nextBytes(r);
                    bb = ByteBuffer.wrap(r);
                    /* Wrap the random byte, so we can get its character
                     * representation */

                    candidate = bb.getChar(0);
                    k++;
                }
            }
            /*
             * Append the character to the password string
             */
            password.append(candidate);
        }
        return password.toString();
    }

    /**
     * This method generates a password of the given length. <P> The password
     * contains characters of the given string:
     * "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890!ยง$%&/()=?`'+*#-.:,;"
     */
    public String generatePassword(int length) {
        StringBuilder password = new StringBuilder();
        char candidate;
        String legalChars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmno"
                + "pqrstuvwxyz1234567890!ยง$%&/()=?`'+*#-.:,;";
        int i, j, k = 0;
        byte[] buf;
        ByteBuffer bb;
        byte[] r = new byte[1];
        boolean isLegal = false;
        /*
         * We need a somewhat random byte stream, but because we're good guys
         * we don't use secureRandom directly as a RNG to fill the hash table.
         * We instead seed our PRNG with a random value from the RNG,
         * so we don't get the same hash table every time the program is run
         */

        /* Generate a seed */
        buf = secgen.generateSeed(8);

        /* Wrap the seed, so we can get it's long value */
        bb = ByteBuffer.wrap(buf);

        /* Set the seed of the PRNG */
        gen.setSeed(bb.getLong());

        for (i = 0; i <= length; i++) {

            /* Get the first random byte in a byte array form */
            gen.nextBytes(r);

            /* Wrap the random byte, so we can get its character
             * representation
             */

            bb = ByteBuffer.wrap(r);


            candidate = bb.getChar(0);
            /*
             * We filter the the output of the RNG, so no control characters are
             * in the password. If there were any in the password, it wouldW
             * screw up either System.out.println() or the attached
             * terminal.
             */
            while (!isLegal) {
                /*
                 * We reseed the PRNG every 150 rounds to avoid even short loops.
                 */
                if (k == 150) {
                    /*
                     * This is just a compressed version of what we do at the
                     * beginning of the method.
                     */
                    gen.setSeed(ByteBuffer.wrap(secgen.generateSeed(8)).getLong());
                    k=0;
                }
                /*
                 * We check if the random character is a legal character
                 */

                for (j = 0; j < legalChars.length() && !isLegal; j++) {
                    if (legalChars.charAt(j) == candidate) {
                        isLegal = true;
                    }
                }
                /*
                 * If it isn't a legal character, we get a new one.
                 */
                if (!isLegal) {
                    gen.nextBytes(r);
                    bb = ByteBuffer.wrap(r);
                    /* Wrap the random byte, so we can get its character
                     * representation */

                    candidate = bb.getChar(0);
                    k++;
                }
            }
            /*
             * Append the character to the password string
             */
            password.append(candidate);
        }
        return password.toString();
    }

    /**
     * This will generate a password of the given length and consisting of the
     * characters in the given string.
     */
    public String generatePassword(int length, String legalChars) {
        StringBuilder password = new StringBuilder();
        char candidate;
        int i, j, k = 0;
        byte[] buf;
        ByteBuffer bb;
        byte[] r = new byte[1];
        boolean isLegal = false;
        /*
         * We need a somewhat random byte stream, but because we're good guys
         * we don't use secureRandom directly as a RNG to fill the hash table.
         * We instead seed our PRNG with a random value from the RNG,
         * so we don't get the same hash table every time the program is run
         */

        /* Generate a seed */
        buf = secgen.generateSeed(8);

        /* Wrap the seed, so we can get it's long value */
        bb = ByteBuffer.wrap(buf);

        /* Set the seed of the PRNG */
        gen.setSeed(bb.getLong());

        for (i = 0; i <= length; i++) {

            /* Get the first random byte in a byte array form */
            gen.nextBytes(r);

            /* Wrap the random byte, so we can get its character
             * representation
             */

            bb = ByteBuffer.wrap(r);


            candidate = bb.getChar(0);
            /*
             * We filter the the output of the RNG, so no control characters are
             * in the password. If there were any in the password, it wouldW
             * screw up either System.out.println() or the attached
             * terminal.
             */
            while (!isLegal) {
                /*
                 * We reseed the PRNG every 150 rounds to avoid even short loops.
                 */
                if (k == 150) {
                    /*
                     * This is just a compressed version of what we do at the
                     * beginning of the method.
                     */
                    gen.setSeed(ByteBuffer.wrap(secgen.generateSeed(8)).getLong());
                }
                /*
                 * We check if the random character is a legal character
                 */

                for (j = 0; j < legalChars.length() && !isLegal; j++) {
                    if (legalChars.charAt(j) == candidate) {
                        isLegal = true;
                    }
                }
                /*
                 * If it isn't a legal character, we get a new one.
                 */
                if (!isLegal) {
                    gen.nextBytes(r);
                    bb = ByteBuffer.wrap(r);
                    /* Wrap the random byte, so we can get its character
                     * representation */

                    candidate = bb.getChar(0);
                    k++;
                }
            }
            /*
             * Append the character to the password string
             */
            password.append(candidate);
        }
        return password.toString();
    }

    /**
     * This function will generate a password of the given length and consisting
     * of the given character array.
     */
    public String generatePassword(int length, char[] legalChars) {
        StringBuilder password = new StringBuilder();
        char candidate;
        int i, j, k = 0;
        byte[] buf;
        ByteBuffer bb;
        byte[] r = new byte[1];
        boolean isLegal = false;
        /*
         * We need a somewhat random byte stream, but because we're good guys
         * we don't use secureRandom directly as a RNG to fill the hash table.
         * We instead seed our PRNG with a random value from the RNG,
         * so we don't get the same hash table every time the program is run
         */

        /* Generate a seed */
        buf = secgen.generateSeed(8);

        /* Wrap the seed, so we can get it's long value */
        bb = ByteBuffer.wrap(buf);

        /* Set the seed of the PRNG */
        gen.setSeed(bb.getLong());

        for (i = 0; i <= length; i++) {

            /* Get the first random byte in a byte array form */
            gen.nextBytes(r);

            /* Wrap the random byte, so we can get its character
             * representation
             */

            bb = ByteBuffer.wrap(r);


            candidate = bb.getChar(0);
            /*
             * We filter the the output of the RNG, so no control characters are
             * in the password. If there were any in the password, it wouldW
             * screw up either System.out.println() or the attached
             * terminal.
             */
            while (!isLegal) {
                /*
                 * We reseed the PRNG every 150 rounds to avoid even short loops.
                 */
                if (k == reSeedThreshold) {
                    /*
                     * This is just a compressed version of what we do at the
                     * beginning of the method.
                     */
                    gen.setSeed(ByteBuffer.wrap(secgen.generateSeed(8)).getLong());
                    k=0;
                }
                /*
                 * We check if the random character is a legal character
                 */

                for (j = 0; j < legalChars.length && !isLegal; j++) {
                    if (legalChars[j] == candidate) {
                        isLegal = true;
                    }
                }
                /*
                 * If it isn't a legal character, we get a new one.
                 */
                if (!isLegal) {
                    gen.nextBytes(r);
                    bb = ByteBuffer.wrap(r);
                    /* Wrap the random byte, so we can get its character
                     * representation */

                    candidate = bb.getChar(0);
                    k++;
                }
            }
            /*
             * Append the character to the password string
             */
            password.append(candidate);
        }
        return password.toString();
    }

    /**
     * This method will generate a hashtable and fill it with the given amount of
     * digest - password pairs.
     */
    public Hashtable makeTable(int amount) {
        return null;

    }
}
