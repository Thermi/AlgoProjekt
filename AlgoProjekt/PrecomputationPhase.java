/**
 *
 * @author thermi
 */
package AlgoProjekt;

import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.ObjectInputStream;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Hashtable;
import java.util.Random;
import java.security.SecureRandom;

/**
 * This class needs to be instanciated first before it can be used.
 * <P>
 * When it is instantiated, it can be used to generate passwords according to a
 * number of parameters.
 */
public class PrecomputationPhase {

    Random gen = new Random();
    SecureRandom secgen = new SecureRandom();
    int reSeedThreshold, counter;

    /**
     * This constructor seeds the PRNG with the given value.
     * @param threshold The threshold specifies when the class should reSeed itself.
     * When it is 0, it disables reSeeding.
     */
    public PrecomputationPhase(int threshold) {
        this.reSeedThreshold = threshold;
        counter = 0;
    }

    public PrecomputationPhase() {
        reSeedThreshold = 0;
        counter = 0;
    }

    /**
     * This method reseeds the PRNG in the object a value from the RNG.
     */
    public void reSeed() {
        gen.setSeed(ByteBuffer.wrap(secgen.generateSeed(8)).getLong());
    }

    /**
     * This method sets the reSeedThreshold to the given value.
     *
     * @param treshold The threshold specifies when the class should reSeed itself.
     * When it is 0, it disables reSeeding.
     */
    public void setReSeedThreshold(int treshold) {
        this.reSeedThreshold = treshold;
    }

    /**
     * This method returns the set threshold.
     * @return Returns the threshold of this object.
    */
    public int getReSeedThreshold() {
        return this.reSeedThreshold;
    }

    /**
     * This function generates a valid password with no control characters in
     * it.
     * <P>
     * It is using Java's PRNG class Random with a seed generated by
     * SecureRandom. The characters in the password are ones from this string:
     * "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890!ยง$%&/()=?`'+*#-.:,;"
     *
     * @return password This is a random password with length 6.
     */
    public String generatePassword() {
        StringBuilder password = new StringBuilder();
        String legalChars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmno"
                + "pqrstuvwxyz1234567890!ยง$%&/()=?`'+*#-.:,;";
        int i, r, l;

        for (i = 0; i <= 6; i++) {

            /*
             * Reseed when the threshold is reached.
             */
            if (reSeedThreshold == counter) {
                reSeed();
                counter = 0;
            }
            /*
             * Append a random character to the password string
             */
            /*
             * We do this to prevent race conditions.
             */
            l = legalChars.length();
            r = gen.nextInt(l);
            password.append(legalChars.charAt(r));
            counter++;
        }
        return password.toString();
    }
    /**
     * This function generates a string consisting of characters, that are found
     * in the parameter "legalChars".
     * <P>
     * It is using the Random class to choose characters from the given String
     * and adds 6 of them to a string, which is then returned.
     *
     * @return A random password with length 6.
     */
    public String generatePassword(String legalChars) {
        /* We still need a
         *
         */
        StringBuilder password = new StringBuilder();
        int i, r, l;

        for (i = 0; i <= 6; i++) {

            /*
             * Reseed when the threshold is reached.
             */
            if (reSeedThreshold > 0 && reSeedThreshold == counter) {
                reSeed();
                counter = 0;
            }
            /*
             * Append a random character to the password string
             */
            /*
             * We do this to prevent race conditions.
             */
            l = legalChars.length();
            r = gen.nextInt(l);
            password.append(legalChars.charAt(r));
            counter++;
        }
        return password.toString();
    }

    /**
     * This method generates a password of the given length.
     * <P>
     * The password contains characters of the given string:
     * "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890!ยง$%&/()=?`'+*#-.:,;"
     * @param length The length of the password you want to generate.
     * @return A string of the given length consisting of random characters.
     */
    public String generatePassword(int length) {
        StringBuilder password = new StringBuilder();
        String legalChars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmno"
                + "pqrstuvwxyz1234567890!ยง$%&/()=?`'+*#-.:,;";
        int i, r, l;

        for (i = 0; i <= length; i++) {

            /*
             * Reseed when the threshold is reached.
             */
            if (reSeedThreshold > 0 && reSeedThreshold == counter) {
                reSeed();
                counter = 0;
            }
            /*
             * Append a random character to the password string
             */
            /*
             * We do this to prevent race conditions.
             */
            l = legalChars.length();
            r = gen.nextInt(l);
            password.append(legalChars.charAt(r));
            counter++;
        }
        return password.toString();
    }

    /**
     * This will generate a password of the given length and consisting of the
     * characters in the given string. <P> In contrast to generatePassword_2,
     * this method does reSeed, if reSeedthreshold ist > 0!
     * @param characters an array of characters you want the passwords to be made up of.
     * @param length The length of the password you want to generate.
     * @return A string of the given length made up of the given characters.
     */
    public String generatePassword_1(String characters, int length) {
        char[] text = new char[length];
        for (int i = 0; i < length; i++) {
            if (reSeedThreshold > 0 && counter == reSeedThreshold) {
                this.reSeed();
                counter = 0;
            }
            text[i] = characters.charAt(gen.nextInt(characters.length()));
            counter++;
        }
        return new String(text);
    }

    /**
     * This function generates a password consisting of the given characters and
     * of the given length.
     * <P>
     * It does no reSeeding. Implemented on behalf of Maria.
     * @param characters A string made up of characters you want the password to be made up of.
     * @param length The length of the password you want to generate.
     * @return A string of the given length made up of the given characters.
     */
    public String generatePassword_2(String characters, int length) {
        char[] text = new char[length];

        for (int i = 0; i < length; i++) {
            text[i] = characters.charAt(gen.nextInt(characters.length()));
        }
        return new String(text);
    }

    /**
     * This function will generate a password of the given length and consisting
     * of the given character array.
     * @param length The length of the password you want to generate.
     * @param legalChars an array of characters you want the passwords to be made up of.
     * @return A string of the given length consisting of random characters.
     */
    public String generatePassword(int length, char[] legalChars) {
        StringBuilder password = new StringBuilder();
        int i, r, l;

        for (i = 0; i < length; i++) {
            i = 0;
            if (reSeedThreshold == counter) {
                reSeed();
                counter = 0;
            }
            /*
             * We do this to prevent race conditions.
             */
            l = legalChars.length;
            r = gen.nextInt(l);
            password.append(legalChars[r]);
            counter++;
        }
        return password.toString();
    }

    /**
     * This method generates the digest of the given string using the given algorithm.
     * @param passwd A string to make the digest of.
     * @param algorithm The algorithm you want to use.
     * @return A byte array holding the last 32 bit of the digest.
     */
    public static byte[] makeDigest(String passwd, String algorithm) {
        byte digest[];
        byte shortenedDigest[] = new byte[4];
        int i;
        MessageDigest md;
        try {
            md = MessageDigest.getInstance(algorithm);
        } catch (NoSuchAlgorithmException e) {
            System.err.println("Sorry, Java doesn't know that algorithm: " + algorithm);
            e.printStackTrace();
            return null;
        }

        digest = md.digest(passwd.getBytes());
        /* We only need the first 32 bit (the first 4 byte), so we copy the
         * last 4 bytes to our own array
         */
        for (i = 0; i < 4; i++) {
            shortenedDigest[i] = digest[digest.length - 4 + i];
        }
        return shortenedDigest;

    }

    /**
     * This method will generate a hashtable that maps byte arrays to strings
     * and fill it with the given amount of digest - password pairs.
     * @param amount This is the amount of entries you want to have in the table.
     * @param legalChars This is a string consisting of the characters you want the passwords
     * to consist of.
     * @return A hash table with "amount" entries that consist of passwords that
     * are made up of the given characters.
     */
    public Hashtable <byte[], String> makeTable(int amount, String legalChars) {
        int i;
        String password;
        Hashtable <byte[], String> table = new Hashtable <byte[], String>();
        for (i = 0; i < amount; i++) {
            password = generatePassword(legalChars);
            table.put(makeDigest(password, "SHA-1"), password);
        }
        return table;
    }
}
