/**
 *
 * @author thermi
 */
package AlgoProjekt;

import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.ObjectInputStream;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Hashtable;
import java.util.Random;
import java.security.SecureRandom;

/**
 * This class needs to be instanciated first before it can be used. <P> When it
 * is instantiated, it can be used to generate passwords according to a number
 * of parameters.
 */
public class PrecomputationPhase {

    private Random gen = new Random();
    private SecureRandom secgen = new SecureRandom();
    private int reSeedThreshold;
    private int counter;

    public PrecomputationPhase() {
        reSeedThreshold = 150;
        byte[] buf;
        ByteBuffer bb;
        /* Generate a seed */
        buf = secgen.generateSeed(8);

        /* Wrap the seed, so we can get it's long value */
        bb = ByteBuffer.wrap(buf);

        /* Set the seed of the PRNG */
        this.gen.setSeed(bb.getLong());
    }

    /**
     * This constructor sets the rekeythreshold to the given value.
     */
    public PrecomputationPhase(int threshold) {
        reSeedThreshold = threshold;
        byte[] buf;
        ByteBuffer bb;
        /* Generate a seed */
        buf = secgen.generateSeed(8);

        /* Wrap the seed, so we can get it's long value */
        bb = ByteBuffer.wrap(buf);

        /* Set the seed of the PRNG */
        this.gen.setSeed(bb.getLong());
    }

    /**
     * This constructor seeds the PRNG with the given value.
     */
    public PrecomputationPhase(long seed) {
        /* Set the seed of the PRNG */
        this.gen.setSeed(seed);
    }

    /**
     * This method reseeds the PRNG in the object a value from the RNG.
     */
    public void reSeed() {
        gen.setSeed(ByteBuffer.wrap(secgen.generateSeed(8)).getLong());
    }

    /**
     * This method sets the reSeedThreshold to the given value.
     *
     */
    public void setReSeedThreshold(int treshold) {
        this.reSeedThreshold = treshold;
    }

    public int getReSeedThreshold() {
        return this.reSeedThreshold;
    }

    /**
     * This function generates a valid password with no control characters in
     * it. <P> It is using Java's PRNG class Random with a seed generated by
     * SecureRandom. The characters in the password are ones from this string:
     * "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890!ยง$%&/()=?`'+*#-.:,;"
     *
     */
    public String generatePassword() {
        /* We still need a
         *
         */
        StringBuilder password = new StringBuilder();
        String legalChars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmno"
                + "pqrstuvwxyz1234567890!ยง$%&/()=?`'+*#-.:,;";
        int i, r, l;

        for (i = 0; i <= 6; i++) {

            /*
             * Reseed when the threshold is reached.
             */
            if (reSeedThreshold == counter) {
                reSeed();
                counter = 0;
            }
            /*
             * Append a random character to the password string
             */
            /*
             * We do this to prevent race conditions.
             */
            l = legalChars.length();
            r = gen.nextInt(l);
            password.append(legalChars.charAt(r));
            counter++;
        }
        return password.toString();
    }

    public String generatePassword(String legalChars) {
        /* We still need a
         *
         */
        StringBuilder password = new StringBuilder();
        int i, r, l;

        for (i = 0; i <= 6; i++) {

            /*
             * Reseed when the threshold is reached.
             */
            if (reSeedThreshold == counter) {
                reSeed();
                counter = 0;
            }
            /*
             * Append a random character to the password string
             */
            /*
             * We do this to prevent race conditions.
             */
            l = legalChars.length();
            r = gen.nextInt(l);
            password.append(legalChars.charAt(r));
            counter++;
        }
        return password.toString();
    }

    /**
     * This method generates a password of the given length. <P> The password
     * contains characters of the given string:
     * "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890!ยง$%&/()=?`'+*#-.:,;"
     */
    public String generatePassword(int length) {
        StringBuilder password = new StringBuilder();
        String legalChars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmno"
                + "pqrstuvwxyz1234567890!ยง$%&/()=?`'+*#-.:,;";
        int i, r, l;

        for (i = 0; i <= length; i++) {

            /*
             * Reseed when the threshold is reached.
             */
            if (reSeedThreshold == counter) {
                reSeed();
                counter = 0;
            }
            /*
             * Append a random character to the password string
             */
            /*
             * We do this to prevent race conditions.
             */
            l = legalChars.length();
            r = gen.nextInt(l);
            password.append(legalChars.charAt(r));
            counter++;
        }
        return password.toString();
    }

    /**
     * This will generate a password of the given length and consisting of the
     * characters in the given string.
     */
    public String generatePassword(int length, String legalChars) {
        StringBuilder password = new StringBuilder();
        int i, r, l;

        for (i = 0; i <= length; i++) {

            /*
             * Reseed when the threshold is reached.
             */
            if (reSeedThreshold == counter) {
                reSeed();
                counter = 0;
            }
            /*
             * Append a random character to the password string
             */
            /*
             * We do this to prevent race conditions.
             */
            l = legalChars.length();
            r = gen.nextInt(l);
            password.append(legalChars.charAt(r));
            counter++;
        }
        return password.toString();
    }

    /**
     * This function will generate a password of the given length and consisting
     * of the given character array.
     */
    public String generatePassword(int length, char[] legalChars) {
        StringBuilder password = new StringBuilder();
        int i, r, l;

        for (i = 0; i < length; i++) {
            i = 0;
            if (reSeedThreshold == counter) {
                reSeed();
                counter = 0;
            }
            /*
             * We do this to prevent race conditions.
             */
            l = legalChars.length;
            r = gen.nextInt(l);
            password.append(legalChars[r]);
            counter++;
        }
        return password.toString();
    }

    public static byte[] makeDigest(String passwd, String algorithm) {
        byte digest[];
        byte shortenedDigest[] = new byte[4];
        int i;
        MessageDigest md;
        try {
            md = MessageDigest.getInstance(algorithm);
        } catch (NoSuchAlgorithmException e) {
            System.err.println("Sorrby, Java doesn't know that algorithm: " + algorithm);
            e.printStackTrace();
            return null;
        }

        digest = md.digest(passwd.getBytes());
        /* We only need the first 32 bit (the first 4 byte), so we copy the
         * last 4 bytes to our own array
         */
        for (i = 0; i < 4; i++) {
            shortenedDigest[i] = digest[digest.length - 4 + i];
        }
        return shortenedDigest;

    }

    /**
     * This method will generate a hashtable that maps byte arrays to strings
     * and fill it with the given amount of digest - password pairs.
     */
    public Hashtable makeTable(int amount, String legalChars) {
        int i;
        String password;
        Hashtable table = new Hashtable<byte[], String>();
        for (i = 0; i < amount; i++) {
            password = generatePassword(legalChars);
            table.put(makeDigest(password, "SHA-1"), password);
        }
        return table;
    }
}
